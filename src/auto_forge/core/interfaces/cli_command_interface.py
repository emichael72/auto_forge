"""
Script:         cli_command_interface.py
Author:         AutoForge Team

Description:
    This module defines the `CLICommand` abstract base class, which provides a standardized
    interface for implementing modular, pluggable command-line commands within the AutoForge framework.

    Each command subclass is responsible for:
        - Declaring its name and description.
        - Registering its CLI arguments using `argparse`.
        - Implementing execution logic based on parsed arguments.

    The interface supports both programmatic and shell-style invocation, enabling dynamic discovery
    and execution of commands across tools and environments.
"""

import argparse
import io
import shlex
import time
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from typing import NamedTuple


class _CLICapturingArgumentParser(argparse.ArgumentParser):
    """
        A custom ArgumentParser that captures error messages into an internal string buffer
        instead of printing to stderr and exiting immediately.e.
        """

    def __init__(self, *args, **kwargs):
        """
        Initializes the parser and sets up an internal buffer to capture error messages.
        Args and kwargs are passed directly to the base ArgumentParser constructor.
        """
        self.error_output = io.StringIO()
        super().__init__(*args, **kwargs)

    def exit(self, status=0, message=None):
        """
        Overrides the default exit behavior to capture the message instead of printing.
        Args:
            status (int): Exit code to raise with SystemExit.
            message (str): Optional error message to capture.
        """
        if message:
            self.error_output.write(message.strip())
        raise SystemExit(status)

    def error(self, message):
        """
        Overrides the default error handling to capture the usage message and error text.
        Args:
            message (str): The error message generated by argparse.
        """
        self.print_usage(self.error_output)
        self.error_output.write(f"{self.prog}: error: {message.strip()}\n")
        raise SystemExit(2)

    def get_error_message(self) -> str:
        """
        Returns the captured error message as a trimmed string.
        Returns:
            str: The accumulated error output from the most recent parse attempt.
        """
        return self.error_output.getvalue().strip()


class CLICommandInfo(NamedTuple):
    """ Define a named tuple type for the information data cluster """
    name: str
    description: str
    version:str
    class_name: str
    class_instance: Any


class CLICommandInterface(ABC):
    """
    Abstract base class for CLI commands that can be dynamically registered and executed.
    Each derived class must define its name, description, argument parser, and run logic.
    """

    def __init__(self, raise_exceptions: bool = False):
        """
        Initializes the CLICommand and prepares its argument parser using
        the name and description provided by the subclass.
        Args:
            raise_exceptions (bool): Whether to raise an exception when parsing errors.
        """

        self._command_info: Optional[CLICommandInfo] = None
        self._parser: Optional[_CLICapturingArgumentParser] = None
        self._last_error: Optional[str] = None
        self._raise_exceptions = raise_exceptions

        # Get and store the command info
        self.get_info()

        # Optional tool initialization logic
        if not self.initialize() and self._raise_exceptions:
            raise RuntimeError(f"failed to initialize '{self._command_info.name}' CLI command.")

        super().__init__()

    def _extract_short_arg_map(self) -> Dict[str, str]:
        """
        Dynamically builds a mapping of short option flags (e.g. '-v') to their
        corresponding argument destination names (e.g. 'verbose').

        Returns:
            Dict[str, str]: Mapping from single-letter short options to argparse dest names.
        """
        short_map = {}
        for action in self._parser._actions:
            if action.option_strings and len(action.option_strings) >= 2:
                for opt in action.option_strings:
                    if opt.startswith('-') and not opt.startswith('--'):
                        short_flag = opt.lstrip('-')
                        short_map[short_flag] = action.dest
        return short_map

    def get_last_error(self) -> Optional[str]:
        """
        Returns the last recorded error message, if an error occurred during the previous execution.
        Returns:
            Optional[str]: The error message string, or None if no error was recorded.
        """
        return self._last_error

    def execute(self, flat_args: Optional[str] = None, **kwargs: Any) -> Optional[int]:
        """
        Executes the command using either a shell-style string or structured kwargs.

        Args:
            flat_args (Optional[str]): If provided, a raw shell-style string (e.g., "--flag -v").
            **kwargs: Alternatively, keyword-style argument values (e.g., flag=True, count=3).

        Returns:
            int: 0 on success, non-zero on failure (e.g., usage error).
        """
        # Invalidate last error
        self._last_error = None
        return_value: int = 1

        # Call the mandatory implementation create_parser() to create parser instance if it's not created
        if self._parser is None:
            self._parser: _CLICapturingArgumentParser = _CLICapturingArgumentParser(
                prog=self._command_info.name,
                description=self._command_info.description
            )
            self.create_parser(self._parser)

        if flat_args is not None:
            args_list = shlex.split(flat_args.strip())
        else:
            args_list = []
            for key, value in kwargs.items():
                cli_key = f'--{key.replace("_", "-")}'
                if isinstance(value, bool):
                    if value:
                        args_list.append(cli_key)
                else:
                    args_list.extend([cli_key, str(value)])

        try:
            args = self._parser.parse_args(args_list)
            return_value = self.run(args)
        except SystemExit:
            # Trap argparse attempt to exiot and return non-zero
            self._last_error = self._parser.get_error_message()
        except Exception as execution_exception:  # Propagate any other error
            self._last_error = str(execution_exception).strip()
        finally:
            time.sleep(0.1)
            if self._raise_exceptions and self._last_error is not None:
                raise RuntimeError(self._last_error)

            return return_value

    def initialize(self, **kwargs: Any) -> bool:
        """
        Optional interface method for command-specific one-time initialization.
        Args:
            **kwargs (Any): Optional initialization parameters specific to the command.
        Returns:
            bool: True if initialization succeeded, False otherwise.
        """
        return True

    @abstractmethod
    def get_info(self) -> CLICommandInfo:
        """
        Retrievers information about the implemented command line tool.
        Returns:
            CLICommandInfo: a named tuple containing the implemented command id
        """
        raise NotImplementedError("must implement 'get_info'")

    @abstractmethod
    def create_parser(self, parser: argparse.ArgumentParser) -> None:
        """
        Adds command-specific arguments to the provided parser.

        Args:
            parser (argparse.ArgumentParser): Parser to populate with arguments.
        """
        raise NotImplementedError("must implement 'create_parser'")

    @abstractmethod
    def run(self, args: argparse.Namespace) -> int:
        """
        Executes the actual logic of the command after parsing.

        Args:
            args (argparse.Namespace): Parsed arguments.

        Returns:
            int: 0 on success, non-zero on failure.
        """
        raise NotImplementedError("must implement 'run'")
