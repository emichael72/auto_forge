"""
Script:         command_interface.py
Author:         AutoForge Team

Description:
    Core abstract base class which provides a standardized interface for implementing modular,
    pluggable command-line commands within the AutoForge framework.
    Each command subclass is responsible for:
        - Declaring its name and description.
        - Registering its arguments using `argparse`.
        - Implementing execution logic based on parsed arguments.
"""

import argparse
import inspect
import io
import logging
import shlex
import sys
import time
from abc import ABC, abstractmethod
from contextlib import suppress
from typing import IO, Any, Optional, TYPE_CHECKING

# AutoForge imports
from auto_forge import (AutoForgeModuleType, ModuleInfoType, AutoForgCommandType, CoreContext)

# Lasy import SDK class instance
if TYPE_CHECKING:
    from auto_forge import SDKType

# Module identification
AUTO_FORGE_MODULE_NAME = "CommandInterface"
AUTO_FORGE_MODULE_DESCRIPTION = "Dynamic loadable command interface"


class _CapturingArgumentParser(argparse.ArgumentParser):
    """
    A custom ArgumentParser that captures error messages into an internal string buffer
    instead of printing to stderr and exiting immediately.e.
    """

    def __init__(self, *args, **kwargs):
        """
        Initializes the parser and sets up an internal buffer to capture error messages.
        Args and kwargs are passed directly to the base ArgumentParser constructor.
        """
        self.error_output = io.StringIO()
        super().__init__(*args, **kwargs)

    def exit(self, status=0, message=None):
        """
        Overrides the default exit behavior to capture the message instead of printing.
        Args:
            status (int): Exit code to raise with SystemExit.
            message (str): Optional error message to capture.
        """
        if message:
            self.error_output.write(message.strip())
        raise SystemExit(status)

    def error(self, message):
        """
        Overrides the default error handling to capture the usage message and error text.
        Args:
            message (str): The error message generated by argparse.
        """
        self.print_usage(self.error_output)
        print(f"Error: {message.strip().capitalize()}")

        raise SystemExit(2)

    def get_error_message(self) -> str:
        """
        Returns the captured error message as a trimmed string.
        Returns:
            str: The accumulated error output from the most recent parse attempt.
        """
        return self.error_output.getvalue().strip()

    def print_help(self, _file: Optional[IO[str]] = None) -> None:
        """
        Overrides default help output with a custom help message.
        """
        help_text = self.format_help()

        lines = help_text.splitlines()
        output_lines = []

        skipping_usage = False

        for line in lines:
            stripped_line = line.lstrip()

            if not skipping_usage:
                if stripped_line.startswith("usage:"):
                    skipping_usage = True
                    continue  # Skip the 'usage:' line
                else:
                    output_lines.append(line)
            else:
                # We're in usage-skipping mode
                if stripped_line and not line.startswith(' '):
                    # A non-indented line => stop skipping
                    skipping_usage = False
                    output_lines.append(line)

        # Custom help before 'optional arguments:'
        custom_note = f"Args:\n  Run '{self.prog} --help' to see all available arguments\n"
        final_lines = []
        inserted = False

        for line in output_lines:
            if not inserted and line.strip().lower() == "optional arguments:":
                final_lines.append(custom_note)
                inserted = True
            final_lines.append(line)

        if not inserted:
            final_lines.append(custom_note)

        # 'argparse' essential minor touch-ups
        final_help = "\n".join(final_lines)
        final_help = final_help.replace("optional arguments:", "Optional Arguments:")
        final_help = final_help.replace("show this help message and exit", "Show this help message and exit.")
        print('\n' + final_help)

    def print_usage(self, _file: Optional[IO[str]] = None) -> None:
        """
        Overrides usage banner output.
        """
        self.print_help()


class CommandInterface(ABC):
    """
    Abstract base class for commands that can be dynamically registered and executed.
    Each derived class must define its name, description, argument parser, and run logic.
    """

    # Error constants
    COMMAND_ERROR_NO_ARGUMENTS: int = 0xFFFF
    RESERVED_FLAGS = {"-v", "--version", "-vv", "--verbose", "-t", "--tutorials"}

    def __init__(self, command_name: Optional[str] = None,
                 hidden: Optional[bool] = False,
                 command_type: Optional[AutoForgCommandType] = AutoForgCommandType.MISCELLANEOUS):
        """
        Initializes the command and prepares its argument parser using
        the name and description provided by the subclass.
        Args:.
            command_name (str, optional): The name of the command.
            hidden (bool, optional): Whether to hide commands from the menu.
            command_type (AutoForgCommandType, optional): The type of the command.
            auto_forge (Any): Reference to 'auto_forge' main class
        """

        self._last_error_message: Optional[str] = None
        self._last_exception: Optional[Exception] = None
        self._logger: Optional[logging.Logger] = None
        self._hidden = hidden if hidden else False
        self._command_name: str = command_name
        self._args_parser: Optional[_CapturingArgumentParser] = None
        self._tutorials_relative_path: Optional[str] = None
        self._registry = self.sdk.registry

        # Probe caller globals for command description and name
        caller_frame = inspect.stack()[1].frame
        caller_globals = caller_frame.f_globals
        caller_module_name = caller_globals.get("AUTO_FORGE_MODULE_NAME", None)
        caller_module_description = caller_globals.get("AUTO_FORGE_MODULE_DESCRIPTION", "Description not provided")
        caller_module_version = caller_globals.get("AUTO_FORGE_MODULE_VERSION", "0.0.0")

        self._command_name: str = command_name if command_name is not None else caller_module_name

        # Register this command instance in the global registry for centralized access
        self._module_info: ModuleInfoType = (
            self._registry.register_module(name=command_name, description=caller_module_description,
                                           version=caller_module_version,
                                           auto_forge_module_type=AutoForgeModuleType.COMMAND, hidden=self._hidden,
                                           command_type=command_type))

        # Get configuration from the root auto_forge class through context provider
        self._configuration = CoreContext.get_config_provider().configuration
        self._core_logger = self.sdk.logger
        self._logger = self.sdk.logger.get_logger(name=command_name.capitalize())
        self._tool_box = self.sdk.tool_box

        # Dependencies check
        if None in (self._logger, self._tool_box):
            raise RuntimeError("unable to instantiate dependent core")

        # Optional tool initialization logic
        if not self.initialize():
            raise RuntimeError(f"failed to initialize '{self._module_info.name}' command")

    def _create_parser(self) -> Optional[_CapturingArgumentParser]:
        """
        Call the mandatory implementation of  create_parser() to create parser instance and store it globally and
        protect reserved arguments by removing any conflicting arguments added by the derived class.
        Returns:
            _CapturingArgumentParser: arg parser instance or exception on error.
        """

        def _remove_reserved_arguments():
            """Remove user-defined arguments that collide with reserved ones"""
            actions_to_remove = []
            for action in self._args_parser._actions:
                if any(flag in self.RESERVED_FLAGS for flag in action.option_strings):
                    self._logger.warning(f"Removing user-defined argument {action.option_strings} (reserved).")
                    actions_to_remove.append(action)

            for action in actions_to_remove:
                self._args_parser._actions.remove(action)
                for opt in action.option_strings:
                    self._args_parser._option_string_actions.pop(opt, None)

        if not self._args_parser:
            with suppress(Exception):
                self._args_parser: _CapturingArgumentParser = _CapturingArgumentParser(
                    prog=self._module_info.name, description=self._module_info.description)
                self.create_parser(self._args_parser)

                # Protect reserved arguments
                _remove_reserved_arguments()

                # Ensure all commands support the 'version' and 'verbose' options.
                self._args_parser.add_argument("-v", "--version", action="store_true", help="Show version and exit.")
                self._args_parser.add_argument("-vv", "--verbose", action="store_true",
                                               help="Show more information while running the recipe.")

                # Auto add tutorials if we have an .md file for this command.
                relative_path = f"commands/{self._module_info.name}.md"

                if self._tool_box.resolve_help_file(relative_path=relative_path):
                    self._args_parser.add_argument("-t", "--tutorials", action="store_true",
                                                   help="Show command tutorials.")
                    self._tutorials_relative_path = relative_path

                return self._args_parser

        if self._args_parser is None:
            raise RuntimeError("failed to create parser instance")

        return None

    def get_last_error(self) -> Optional[str]:
        """
        Returns the last recorded error message, if an error occurred during the previous execution.
        Returns:
            Optional[str]: The error message string, or None if no error was recorded.
        """
        return self._last_error_message

    def get_info(self) -> ModuleInfoType:
        """
        Retrievers information about the implemented command line tool.
        Returns:
            ModuleInfoType: a named tuple containing the implemented command id
        """
        if self._module_info is None:
            raise RuntimeError('command info not initialized, make sure call set_info() first')

        return self._module_info

    def update_info(self, command_info: ModuleInfoType):
        """
        Updates information about the implemented command line tool.
        """
        self._module_info = command_info

    def get_known_args(self, raise_exceptions: bool = False) -> Optional[list[str]]:
        """
        Returns a concise list of known command-line arguments defined in the internal ArgumentParser.
        This can be used for autocompletion or shell suggestions.
        Args:
            raise_exceptions (bool): If True, re-raises any exceptions encountered. Otherwise, returns None on error.
        Returns:
            Optional[list[str]]: A list of option strings (e.g., ['--input', '-f']) or None if an error occurs.
        """
        try:
            # Ensure the argument parser is initialized
            self._create_parser()

            long_options = []
            for action in self._args_parser._actions:
                long_form = next((opt for opt in action.option_strings if opt.startswith("--")), None)
                if long_form:
                    long_options.append(long_form)
                elif action.option_strings:
                    long_options.append(action.option_strings[0])  # fallback to short if no long
            return long_options


        except Exception as parser_exception:
            if raise_exceptions:
                raise RuntimeError("failed to extract known arguments") from parser_exception
            return None

    def execute(self, flat_args: Optional[str] = None, **kwargs: Any) -> Optional[int]:
        """
        Executes the command using either a shell-style string or structured kwargs.
        Args:
            flat_args (Optional[str]): If provided, a raw shell-style string (e.g., "--flag -v").
            **kwargs: Alternatively, keyword-style argument values (e.g., flag=True, count=3).

        Returns:
            int: 0 on success, non-zero on failure (e.g., usage error).
        """

        def _normalize_error(_s: str) -> str:
            """ Make sure the error message is trimmed, capitalized and has dit at the end """
            if not isinstance(_s, str):
                return _s
            _s = _s.strip().capitalize()
            return _s if _s.endswith('.') else _s + '.'

        # Invalidate last error
        self._last_error_message = None
        return_value: int = 1
        verbose: bool = False

        #
        # Ensure the argument parser is initialized.
        self._create_parser()

        if flat_args is not None:
            args_list = shlex.split(flat_args.strip())
        else:
            args_list = []
            for key, value in kwargs.items():
                cli_key = f'--{key.replace("_", "-")}'
                if isinstance(value, bool):
                    if value:
                        args_list.append(cli_key)
                else:
                    args_list.extend([cli_key, str(value)])
        try:

            # Handle arguments special care for version output
            if "-v" in args_list or "--version" in args_list:
                print(f"AutoForge '{self._module_info.name}' version {self._module_info.version}")
                return_value = 0

            # Handle tutorials request
            elif "-t" in args_list or "--tutorials" in args_list:
                if self._tutorials_relative_path:
                    return_value = self._tool_box.show_help_file(relative_path=self._tutorials_relative_path)
                else:
                    raise RuntimeError('tutorials ware not found for this command')

            else:
                args = self._args_parser.parse_args(args_list)
                # Handle verbosity
                if "-vv" in args_list or "--verbose" in args_list:
                    self._core_logger.set_output_enabled(logger=self._logger, state=True)
                    verbose = True

                return_value = self.run(args)

            # Auto print help when no arguments provided
            if return_value == self.COMMAND_ERROR_NO_ARGUMENTS:
                self._args_parser.print_help()
                return_value = 1

        except SystemExit:
            # Suppress any attempt to exit
            self._last_exception = None
            return_value = 0
        except Exception as execution_exception:
            self._last_error_message = _normalize_error(str(execution_exception))
            self._last_exception = execution_exception
        finally:
            time.sleep(0.1)
            if return_value and self._last_error_message is not None:
                if self._last_exception:
                    raise RuntimeError(self._last_error_message) from self._last_exception
                else:
                    raise RuntimeError(self._last_error_message)

            sys.stdout.flush()

            if verbose:
                # Restore verbosity
                self._core_logger.set_output_enabled(logger=self._logger, state=False)

        return return_value

    # noinspection PyMethodMayBeStatic
    def initialize(self, **_kwargs: Any) -> bool:
        """
        Optional interface method for command-specific one-time initialization.
        Args:
            **_kwargs (Any): Optional initialization parameters specific to the command.
        Returns:
            bool: True if initialization succeeded, False otherwise.
        """
        return True

    @abstractmethod
    def create_parser(self, parser: argparse.ArgumentParser) -> None:
        """
        Adds command-specific arguments to the provided parser.
        Args:
            parser (argparse.ArgumentParser): Parser to populate with arguments.
        """
        raise NotImplementedError("must implement 'create_parser'")

    @abstractmethod
    def run(self, args: argparse.Namespace) -> int:
        """
        Executes the actual logic of the command after parsing.
        Args:
            args (argparse.Namespace): Parsed arguments.
        Returns:
            int: 0 on success, non-zero on failure.
        """
        raise NotImplementedError("must implement 'run'")

    @property
    def sdk(self) -> Optional["SDKType"]:
        """
        Returns the global SDK singleton instance, which holds references
        to all registered core module instances.
        This property provides convenient access to the centralized SDKType
        container, after all core modules have registered themselves during
        initialization.
        """
        from auto_forge import SDKType
        return SDKType.get_instance()
