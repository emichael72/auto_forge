#!/bin/bash

# ------------------------------------------------------------------------------
#
# Script Name:    env.sh
# Description:    AutoForge shell environment initiator.
#
# ------------------------------------------------------------------------------

print_help() {

	echo "Usage: $(basename "$0") [OPTION]"
	echo ""
	echo "Options:"
	echo "  -d, --debug_port PORT   Optional set remote debugging port for local host (127.0.0.1)"
	echo "  -v, --version           Print version and exit"
	echo "  -?, --help              Show this help message"
	echo ""
	echo "When no option is provided, only the virtual environment is activated."
}

#
# @brief Reads a key's value from a local '.config' file generated by the solution installer.
#
# The .config file is expected to reside in the current working directory and follow a simple
# key=value format. Lines starting with '#' are treated as comments and ignored.
#
# Keys and values are trimmed of leading/trailing whitespace. If the key is not found,
# the function returns an empty string but exits with status 0.
#
# @param key The configuration key to look up (e.g., 'solution_name').
# @return Prints the corresponding value to stdout, or nothing if the key is not found.
#         Returns 0 on success, 1 if the .config file is missing.
#
# @code
# Example .config file:
# ----------------------
# .config - Auto-generated by solution installer
# solution_name=sample
# install_date=2025-05-13T19:45:00
#
#

get_config_value() {

	local key="$1"
	local config_file=".config"

	if [[ ! -f "$config_file" ]]; then
		echo "Error: $config_file not found" >&2
		return 1
	fi

	# Strip whitespace and extract the value for the given key
	local value
	value=$(grep -E "^\s*${key}\s*=" "$config_file" | sed -E "s/^\s*${key}\s*=\s*//" | head -n 1)

	if [[ -z "$value" ]]; then
		echo "Error: Key '$key' not found in $config_file" >&2
		return 2
	fi

	# Cleanup
	echo "$value" | tr -d '\r' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g'
	return 0
}

#
# @brief AutoForge solution entry point.
# @return Returns 0 on overall success, else failure.
#

main() {

	local solution_name
	local script_dir
	local venv_path=".venv/bin/activate"
	local debug_port=""
	local show_version=0

	# Determine the script's directory (works in both bash and zsh)
	if [[ -n "${BASH_SOURCE:-}" ]]; then
		script_path="${BASH_SOURCE[0]}"
	else
		script_path="$0"
	fi

	script_dir="$(cd "$(dirname "$script_path")" && pwd)"

	# Change to the workspace (script) directory
	cd "$script_dir" || {
		echo "Error: Failed to change to workspace directory '$script_dir'"
		return 1
	}

	# Get the solution name from the auto generated config file.
	solution_name=$(get_config_value solution_name)
	if [[ -z "$solution_name" ]]; then
		echo "No solution name found, using default."
	fi

	# Argument parsing
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-d | --debug_port)
				if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -ge 0 && "$2" -le 65535 ]]; then
					debug_port="$2"
					shift
				else
					echo "Error: Invalid or missing port for $1"
					return 4
				fi
				;;
			-v | --version)
				show_version=1
				;;
			-\? | --help)
				print_help
				return 0
				;;
			*)
				echo "Error: Unknown option '$1'"
				print_help
				return 5
				;;
		esac
		shift
	done

	# Check if virtual environment exists
	if [[ ! -f "$venv_path" ]]; then
		echo "Error: Python virtual environment not found at $venv_path"
		return 1
	fi

	# Source the virtual environment
	# shellcheck source=.venv/bin/activate
	source "$venv_path"

	# Check if 'autoforge' is available
	if ! command -v autoforge >/dev/null 2>&1; then
		echo "Error: 'autoforge' command not found in PATH"
		return 2
	fi

	# Show version if requested
	if [[ "$show_version" -eq 1 ]]; then
		autoforge -v
		return $?
	fi

	# Build command
	local cmd=(autoforge -n "$solution_name" -w .)
	if [[ -n "$debug_port" ]]; then
		cmd+=(--remote-debugging "127.0.0.1:$debug_port")
	fi

	"${cmd[@]}"
	return $?
}

#
# @brief Invoke the main function with command-line arguments.
# @return The exit status of the main function.
#

main "$@"
exit $?
